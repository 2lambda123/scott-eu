<h1>vrep<em>ros</em>control_example - TurtleBot2i</h1>

<p>This package contains a ros<em>control back end for the PhantomXArm (TurtleBot2i Arm) simulated on VREP. This package was based on the vrep</em>ros<em>control</em>example available at https://github.com/ros-controls/ros_control</p>

<p>MOTIVATION</p>

<p>Packages that are broadly used like the MoveIt! require the robot to have an action server to consume trajectory's messages. This kind of server aim to be used when an long tasks is being executed and a feedback or a stop action is need while the process is running (http://wiki.ros.org/actionlib). Instead of developing a specific action server to consume MoveIt! messages, the MoveIt documentations advise to use a ros_controller (http://moveit.ros.org/documentation/concepts/) as can be seen on the picture below.</p>

<p><img src="moveit.jpg" alt="alt_text" title="" /></p>

<p>Also, as our project will use a real TurtleBot, is a good practice to have simulation and real robot operating similar as possible. </p>

<p>ROS_CONTROL</p>

<p>Disclaimer: The documentation is very sparse and sometimes it's hard to put all the different concepts together. On the following paragraphs I will give my understand about how the ROS_CONTROL works, although it's important to keep in mind that I'm probably wrong or lacking some important concepts. For a more accurate documentation consult consult the links on the following sections</p>

<p>The ROS<em>CONTROL basically takes an set</em>point and joints states. With a, lets say, a PID controller, it sends a command to the joints. But in order to do so, many components must be available.
   Lets consider that we a have a moveIt! node publishing (via actionLib) a trajectory. Thus, we'll a need a controller to read joints states, the input/set point from moveIt! and send commands to joints. To accomplish that, we'll need 3 main components: a Controller Manager, a Controller(Trajectory Controller) and a Hardware Interface.</p>

<ul>
<li><p>Controller
 Briefly: This can be a simple Controller, like a PID. There's many kinds available on ROS, E.g: position, velocity, effort, trajectory.
 http://wiki.ros.org/ros_controllers</p></li>
<li><p>Controller Manager
 http://wiki.ros.org/controller_manager
 This component is responsible to spawn a Controller and will do the interface between the Controller and Hardware Interface.
 The Controller Manager will provide an interface to load, start, stop and unload a controller. It will also keep an internal state machine relative to the control loop execution.
 Apparently, the controller manager will manage the interface to read from the Hardware the joints states and write a command to the joints. Inside the controller manager, those interfaces are agnostic from the robot's hardware perspective. So, the Controller Manager provides a general propose interface between the controller and the robot's hardware.</p>

<p>TLDR.: Provides an general interface between hardware and controller, keep track of the Controller (start, stop, load, unload).</p></li>
<li><p>Hardware Interface
 https://github.com/ros-controls/ros<em>control/wiki/hardware</em>interface</p>

<p>This component will provide an software abstraction of the robot's hardware. It will made available the respective interfaces to the controller read joint states and send the correct kind of commands to joints. There are three main interfaces joint_state, velocity, position and effort.</p>

<p>TLDR.: It's here where you code read and write functions. This will provide an interface to the ros_manager to read states and send commands.</p>

<p>A diagram to help:</p>

<p><img src="how_works.png" alt="alt text" title="" /></p></li>
</ul>

<p>HOW TO RUN IT (based on the original vrep<em>ros</em>control_example)</p>

<ul>
<li>clone the repository in your <workspace>/src folder</li>
<li>build the newly cloned package.
<ul>
<li>E.g.: on <workspace>/src folder run: catkin_make</li>
</ul></li>
<li>once built, you need to copy this plugin file libv_repExtRosControl.so from your <workspace>/build/lib folder to vrep's main folder (along all the other plugins)</li>
<li>start a terminal with roscore</li>
<li>then start vrep and load vrep/turttlebot2<em>v4.ttt
<ul>
<li>check that plugin libv</em>repExtRosControl.so is correctly loaded in vrep's trace (i.e. in vrep's console)</li>
</ul></li>
<li>start the simulation in vrep</li>
<li>start another terminal and launch file vrep.launch
<ul>
<li>roslaunch vrep<em>ros</em>control<em>example vrep</em>phantom.launch</li>
</ul></li>
<li>start yet another terminal and run action/test<em>move.py
<ul>
<li>it creates a follow<em>joint</em>trajectory action so as to give a goal to your controller and move your robot</li>
<li>roscd vrep<em>ros</em>control</em>example</li>
<li>cd action</li>
<li>./test<em>move.py follow</em>joint<em>trajectory:=phantom</em>controller/follow<em>joint</em>trajectory</li>
<li>The mobile robot arm should go back for 1 second and forth for another second</li>
<li>./test<em>move</em>gripper.py gripper<em>command:=gripper</em>controller/gripper_cmd</li>
<li>The arm gripper should open</li>
</ul></li>
</ul>

<p>HOW IT WORKS</p>

<p>In order to create a ros_control back end for vrep:</p>

<ul>
<li>obviously you need a .ttt vrep file corresponding to your simulated system
<ul>
<li>this is file vrep/turttlebot2_v4.ttt in the current case</li>
</ul></li>
<li>The file src/ControlLoop/Phantom<em>vrepHW.cpp was modified to meet the simulated turtlebot2i hardware interface
<ul>
<li>the other files like vrepControl<em>plugin .h or .cpp and vrepControl</em>server .h or .cpp are generic and should not be changed</li>
<li>files src/v</em>rep* are directly copied from vrep (and needed to create a plugin), they should not be changed</li>
</ul></li>
<li>unfortunately you need a redundant description of your robot in urdf (so your robot is described both in the .ttt file and in the urdf)
<ul>
<li>this is because the urdf contains information on the joints and transmissions not contained in the vrep .ttt file</li>
<li>to counterbalance this point, note that the urdf importer works pretty well. But once your urdf is imported and you modify something in vrep's .ttt file you need to redundantly modify it in the urdf (I told Coppelia about this situation but unfortunately did not receive an answer)</li>
</ul></li>
<li>this plugin is based on the blank ros skeleton plugin vrep<em>plugin</em>skeleton provided in vrep's folder programming/ros<em>packages/vrep</em>plugin_skeleton</li>
</ul>

<p>Please look at the code if you want to understand how the plugin works, it should be self explaining for people who know well about vrep and ros<em>control, and it is well commented for the others. The main "trick" is in function "bool ROS</em>server::initialize()" in file vrepControl_server.cpp.</p>
